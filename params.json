{"name":"Dep","body":"DEP(1) -- basic dependency tracking\r\n===================================\r\n\r\n## SYNOPSIS\r\n\r\n    dep check\r\n    dep add libname [--pre]\r\n    dep rm libname\r\n    dep install\r\n\r\n## DESCRIPTION\r\n\r\n   * check:\r\n     Checks that all dependencies are met.\r\n\r\n   * add:\r\n     Fetches the latest version of the library in question\r\n     and automatically adds it to your .gems file.\r\n\r\n   * rm:\r\n     Simply removes the corresponding entry in your .gems file.\r\n\r\n   * install:\r\n     Installs all the missing dependencies for you. An important\r\n     point here is that it simply does a `gem install` for each\r\n     dependency you have. Dep assumes that you use some form of\r\n     sandboxing like gs, RVM or rbenv-gemset.\r\n\r\n\r\n## INSTALLATION\r\n\r\n    $ gem install dep\r\n\r\n## HISTORY\r\n\r\ndep is actually more of a workflow than a tool. If you think about\r\npackage managers and the problem of dependencies, you can summarize\r\nwhat you absolutely need from them in just two points:\r\n\r\n1. When you build an application which relies on 3rd party libraries,\r\nit's best to explicitly declare the version numbers of these\r\nlibraries.\r\n2. You can either bundle the specific library version together with\r\nyour application, or you can have a list of versions.\r\n\r\nThe first approach is handled by vendoring the library. The second\r\napproach typically is done using Bundler. But why do you need such\r\na complicated tool when all you need is simply listing version numbers?\r\n\r\nWe dissected what we were doing and eventually reached the following\r\nworkflow:\r\n\r\n1. We maintain a .gems file for every application which lists the\r\nlibraries and the version numbers.\r\n2. We omit dependencies of dependencies in that file, the reason being\r\nis that that should already be handled by the package manager\r\n(typically rubygems).\r\n3. Whenever we add a new library, we add the latest version.\r\n4. When we pull the latest changes, we want to be able to rapidly\r\ncheck if the dependencies we have is up to date and matches what\r\nwe just pulled.\r\n\r\nSo after doing this workflow manually for a while, we decided to\r\nbuild the simplest tool to aid us with our workflow.\r\n\r\n- The first point is handled implicitly by dep. You can also specify\r\na different file by doing dep -f.\r\n- The second point is more of an implementation detail. We thought about\r\ndoing dependencies, but then, why re-implement something that's already\r\ndone for you by rubygems?\r\n- The third point (and also the one which is most inconvenient), is\r\nhandled by dep add.\r\n\r\nThe manual workflow for `dep add` would be:\r\n\r\n    gem search -r \"^ohm$\" [--pre] # check and remember the version number\r\n    echo \"ohm -v X.x.x\" >> .gems\r\n\r\nIf you try doing that repeatedly, it will quickly become cumbersome.\r\n\r\nThe fourth and final point is handled by typing dep check or simply dep.\r\nPractically speaking it's just:\r\n\r\n```\r\ngit pull\r\ndep\r\n```\r\n\r\nAnd that's it. The dep command typically happens in 0.2 seconds which\r\nis something we LOVE.\r\n","tagline":"","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}